<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="includeHTML.js" type="text/js"">
    <title>첫 번째</title>
    <style>
      @import url("style.css");
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap");
      @import url("includeHTML.js");
    </style>
  </head>
  <header>
    <header>
        <span class="previous"><a href="start.html">💕</a></span>
        <span class="title">Java To Solidity</span>
        <span class="next"><a href="2.html">💕</a></span>
    </header>
  </header>
  <body>
    <div class="container">
      <div class="item">
        <h1>개념설명</h1>
        <div class="box">
          <div class="text"><details>
            <summary>pragma solidity + ^버전정보</summary>
            <p>Pragma를 통해 솔리디티 컴파일러 버전을 제한합니다.</p>
        </details>
        <details>
            <summary>Contract</summary>
            <p>Contract를 통해 이 코드가 스마트 컨트랙트임을 나타냅니다. 솔리디티의 컨트랙트는 자바의 클래스로 나타냈습니다.<br>컨트랙트는 상속과 다형성을 지원하므로 다른 컨트랙트로부터 상속되거나 한 솔리디티 파일에 여러 개의 컨트랙트가 정의될 수 있습니다.</p>
        </details>
        <details>
            <summary>Struct</summary>
            <p>필요한 자료형들을 가지고 새롭게 정의하는 사용자 정의 타입으로 솔리디티의 구조체입니다.<br>함수 외부에서 구조체를 명시하면 storage에 저장되고 함수 내부에서 구조체를 명시하면 memory에 저장됩니다.<br>(간단하게 말하면 storage는 영구 저장, memory는 임시 저장입니다. 자세한 건 밑에 따로 설명했습니다.)</p>
        </details>
        <details>
            <summary>값 타입</summary>
            <p>bool : 논리자료형 true/false.<br>
                int : 정수형<br>
                uint : 부호가 없는 정수형 unsigned int. 솔리디티는 주로 uint 사용<br>
                address : 크기가 20bytes인 이더리움 주소 값 (0xbFv15646A0…)<br>
                bytes : 바이트. 문자열저장<br>
                enum : 열거형<br>
                Java와 Solidity는  값 타입을 적는 순서에 약간의 차이가 있다.<br> 
                Java> public int a;<br>
                Solidity> uint public a;
            </p>
        </details>
        <details>
            <summary>매핑(mapping)</summary>
            <p>- 구조화된 데이터를 저장하는 방법.<br>
                - Key&Value를 쌍으로 저장<br>
                - mapping (Key(=address)=>Value(=uint))와 같은 형태로 사용<br>
                Java> public HashMap&lt;address, Voter&gt;voters = new HashMap&lt;address, Voter&gt;;<br>
                Solidity> mapping(address => Voter) public voters;
            </p>
        </details>
        <details>
            <summary>배열</summary>
            <p>같은 타입의 변수들을 묶은 자료구조</p>
        </details>
        <details>
            <summary>생성자(Constructor)</summary>
            <p>-객체의 초기화가 필요하다면 생성자 안에 작성<br>
                -생성자를 사용하려면 단 1개만 작성해야 한다. 2개 이상 사용시 오류 발생<br>
                -생성자를 직접 작성하지 않으면 기본생성자(default constructor) 자동 생성<br>
                -생성자의 가시성은 internal 또는 public<br>
                >생성자는 특별한 함수이기 때문에 자바 코드에선 함수로 나타내었다. Solidity 코드로 작성할 때는 함수가 아닌 constructor로 바꾸어 작성하세요.<br>
            </p>
        </details>
        <details>
            <summary>데이터 위치</summary>
            <p>memory<br>
                임시적으로 저장되는 변수를 말합니다. 이는 contract 함수에 대한 외부 호출들이 일어나는 사이에 지워집니다. 매개변수와 리턴값은 memory로 선언합니다.<br><br>
                storage<br>
                블록체인에 영구적으로 저장되는 변수를 말합니다. 저장되는 변수의 종류는 상태 변수, 함수 내 로컬 변수가 있습니다.
            </p>
        </details>
        <details>
            <summary>msg.sender</summary>
            <p>현재 함수를 호출한 사람 (혹은 스마트 컨트랙트)의 주소이며 모든 함수에서 이용 가능한 전역 변수입니다.</p>
        </details>
        <details>
            <summary>메세지 프로퍼티(Message Properties)</summary>
            <p>계약은 msg 프로퍼티를 사용해 계약을 호출한 사람이 보낸 메세지를 확인합니다. msg 프로퍼티는 다음과 같은 정보를 담습니다.<br>
                <table>
                    <tr>
                        <th>정보</th>
                        <th>타입</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td>data</td>
                        <td>byte</td>
                        <td>호출 데이터</td>
                    </tr>
                    <tr>
                        <td>sender</td>
                        <td>address</td>
                        <td>계약을 호출한 이더리움 주소</td>
                    </tr>
                    <tr>
                        <td>value</td>
                        <td>uint</td>
                        <td>계약 주소로 보낸 Ether량</td>
                    </tr>
                    <tr>
                        <td>gas</td>
                        <td>uint</td>
                        <td>gas limit에서 함수를 호출하고 남은 가스</td>
                    </tr>
                </table>
                </p>
        </details>
        <details>
            <summary>Push</summary>
            <p>Solidity는 push를 이용하여 배열에 값을 입력 한다.<br>
                Java code><br> 
                proposals.name=proposalNames[i];<br>
                &nbsp;&nbsp;&nbsp;&nbsp;proposals.voteCount=0;<br>
                Solidity code><br>
                proposals.push(Proposal({<br>
                &nbsp;&nbsp;&nbsp;&nbsp;name: proposalNames[i],<br>
                &nbsp;&nbsp;&nbsp;&nbsp;voteCount: 0<br>
                })
                </p>
        </details>
        <details>
            <summary>접근제어자(가시성)</summary>
            <p>-external : 외부컨트랙트만 접근가능(같은 함수 내부에서 호출되면 안됨), 상태변수는 external 불가능<br><br>
                -internal : 컨트랙트 내부호출가능, 상속받은 컨트랙트도 호출가능, 상태변수는 디폴트로 internal 선언<br><br>
                -public : 컨트랙트 내부호출 가능, 상속받은 컨트랙트도 호출가능, 외부컨트랙트도 호출가능<br><br>
                -private: 컨트랙트 내부만 호출가능
                </p>
        </details>
        <details>
            <summary>함수(function)</summary>
            <p>기본적으로 함수는 public.<br>
                함수는 다음과 같이 사용한다. 자바 함수와는 순서가 약간 다르다.<br>
                솔리디티 코드 ex><br>
                fuction nameA(address a) public view returns(uint b) {<br>
                // 함수 내용<br>
                }
                </p>
        </details>
        <details>
            <summary>returns</summary>
            <p>솔리디티는 반환값의 타입을 지정해줘야하며 다중 반환값 처리는 순서대로 처리 된다.</p>
        </details>
        <details>
            <summary>함수제어자(function modifier)</summary>
            <p>-View : 데이터를 읽을 수만 있습니다. 상태 변화가 없는 함수에는 view를 붙입니다. 즉, 함수는 데이터를 보기만하고 변경하지 않는다는 뜻입니다.<br><br>
                -pure : 어떤 데이터도 접근하지 않는 것을 의미합니다. 함수에 전달된 인자값에 따라서 반환값이 정해집니다.
                </p>
        </details>
        <details>
            <summary>require</summary>
            <p>함수 실행 전에 참이어야 하는 특정 조건을 확인하는 데 사용합니다. 특정 조건이 참이 아닐 때 함수가 에러 메세지를 발생하고 실행을 멈추게 됩니다.<br>
                자바 코드><br>
                if (msg.sender != chairperson) { <br>
                &nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Only chairperson can give right to vote.");<br>
                &nbsp;&nbsp;&nbsp;&nbsp;System.exit(0); // 실행 멈추는 코드<br>
                }<br>
                솔리디티 코드><br>
                require(<br>
                &nbsp;&nbsp;&nbsp;&nbsp;msg.sender == chairperson,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;"Only chairperson can give right to vote."<br>
                );
                </p>
        </details>
        <details>
            <summary>event</summary>
            <p>event는 Dapp의 데이터 출력 수단(Log)입니다. 이벤트를 선언 후 이 이벤트를 호출하면 매개변수값과 함께 호출한 기록이 Transaction Receipt 라 불리는 트랜잭션 결과에 저장됩니다.<br>
                (DApp이란 스마트 컨트랙트를 구현한 블록체인의 탈중앙화 분산 애플리케이션)
                </p>
        </details>
        <details>
            <summary>_</summary>
            <p>함수 인자명 앞 또는 private 제한자가 붙은 함수명 앞에 _를 붙여야합니다.</p>
        </details>
        <details>
            <summary>transfer</summary>
            <p>계약이 다른 이에게 Ether를 전송하는 함수입니다.</p>
        </details>
        <details>
            <summary>send</summary>
            <p>send는 address의 멤버변수로 해당 주소에게로 송금하는 함수입니다.</p>
        </details>
        <details>
            <summary>함수제어자(modifier)</summary>
            <p>함수가 실행되기 전에 요구조건을 만족시키는지 확인하는 작업을 해줍니다.<br>
                다른 함수들에 대한 접근을 제어하기 위해 사용되는 유사 함수입니다. 보통 함수 실행 전에 요구사항 충족 여부를 확인하는데 사용합니다.<br>
                함수 인자명 앞 또는 private 제한자가 붙은 함수명 앞에 _를 붙여야합니다.<br>
                선언과 사용은 함수 제어자 마지막에 _;를 붙여 나머지 내용을 실행할 수 있도록 해주어야합니다.<br>
                </p>
        </details>
        <details>
            <summary>payable</summary>
            <p>payable 키워드는 계약 계정에 외부에서 이더를 송금 받을 수 있도록 합니다. 즉, 계약이 A에게 송금을 받으려면 A가 호출하는 함수에 payable 키워드가 있어야합니다.<br>
                payable 함수는 다음과 같이 사용합니다.<br>
                function 함수이름() payable public { <br>
                //함수 내용<br>
                }
                </p>
        </details>
        <details>
            <summary>enum</summary>
            <p>Enum은 열거형으로 사용자 정의 타입을 만드는 한 가지 방법입니다. <br>
                - 열거형(index를 부여한 자료형)<br>
                - 값을 정수타입으로 리턴
                </p>
        </details>
        <details>
            <summary>emit</summary>
            <p>emit이란 키워드를 이용하여 이벤트를 발생시킨다</p>
        </details>
        <details>
            <summary>selfdestruct</summary>
            <p>받는 사람 주소를 뜻하며 현재 컨트랙트를 삭제하고 계정의 나머지 이더를 받는 사람 주소로 보냅니다.</p>
        </details>
        <details>
            <summary>어셈블리(assembly)</summary>
            <p>low level에서 EVM에 접근하는 방법입니다.</p>
        </details>
        </div>
          
        </div>
      </div>
      <div class="item">
        <h1>투표</h1>
        <div class="box">
          <div class="text">
            <pre>
// class => struct
class Voter {
        uint weight; 
        bool voted;
        address delegate; 
        uint vote;
}
//class => struct
class Proposal {
   bytes32 name;
    uint voteCount;
}
//public class => contract
public class Ballot {   
   public static void main(String[] args) {
      
       public address chairperson; 

       public HashMap&lt;address,Voter> voters = new HashMap&lt;address,Voter>(); 
       // => mapping(address=>Voter) public voters;
       public Proposal[] proposals;
       
       //public Ballot => constructor
       public Ballot(byte32[] memory proposalNames) { 
           chairperson = msg.sender;
           voters[chairperson].weight = 1;

           for (uint i = 0; i &lt; proposalNames.length; i++) { //*.length은 배열의 고정된 길이를 반환합니다.
              proposals.name=proposalNames[i];
               proposals.voteCount=0;
           }
       }

       public void giveRightToVote(address voter) {
          
            if (msg.sender != chairperson) { 
               System.out.println("Only chairperson can give right to vote.");
               System.exit(0);
           }
           if (voters[voter].voted) {
               System.out.println("The voter already voted.");
               System.exit(0);
           }
           if (voters[voter].weight != 0)
              System.exit(0);
           voters[voter].weight = 1;


       public void delegate(address to) {

          storage Voter sender = voters[msg.sender];

          if (sender.voted) {
              System.out.println("You already voted.");
              System.exit(0);
           }

           if (to == msg.sender) {
              System.out.println("Self-delegation is disallowed.");
              System.exit(0); 
           }

           while (voters[to].delegate != address(0)) {
               to = voters[to].delegate;

               if (to == msg.sender) {
                    System.out.println("Found loop in delegation.");
                    System.exit(0);
               }
           }


           sender.voted = true;
           sender.delegate = to;
           storage Voter delegate_ = voters[to];
           if (delegate_.voted) {
               proposals[delegate_.vote].voteCount += sender.weight;
           } else {
               delegate_.weight += sender.weight;
           }
       }

       public void vote(uint proposal) {
           storage Voter sender = voters[msg.sender];
           if (sender.weight == 0) {
              System.out.println("Has no right to vote");
              System.exit(0);
           }
           if(sender.voted) {
              System.out.println("Already voted.");
              System.exit(0);
           }
           sender.voted = true;
           sender.vote = proposal;if (sender.weight == 0) {
              System.out.println("Has no right to vote");
              System.exit(0);
           }
           if (sender.voted) {
              System.out.println("Already voted.");
              System.exit(0); 
           }
           sender.voted = true;
           sender.vote = proposal;


           proposals[proposal].voteCount += sender.weight;
       }


       public uint winningProposal() view {

           int winningVoteCount = 0;
           for (uint p = 0; p &lt; proposals.length; p++) {
               if (proposals[p].voteCount > winningVoteCount) {
                    winningVoteCount = proposals[p].voteCount;
                    winningProposal_ = p;
               }
           }
           return winningProposal_;
       }

       public byte[] winnerName() view {
           winnerName_ = proposals[winningProposal()].name;
           return (bytes32 winnerName_);
        }
   }
   
   }

}
            </pre>
            </div>
        </div>
      </div>
      <div class="item">
        <h1>입력창</h1>
        <div class="box">
          <div class="text">
            <pre>
pragma solidity ^0.4.16;

/// @title 위임 투표.
    </pre>
            <form action="" id="my_form_17">
                <textarea id="code17" name="code" placeholder="코드를 입력해주세요."></textarea>
                <input type="submit" value="제출하기" id="_submit17"><br>
            </form>
        <pre>
    // 이것은 나중에 변수에 사용될 새로운
    // 복합 유형을 선언합니다.
    // 이것은 단일 유권자를 대표할 것입니다.
        </pre>
            <form action="" id="my_form_18">
                <textarea id="code18" name="code" placeholder="코드를 입력해주세요."></textarea>
                <input type="submit" value="제출하기" id="_submit18"><br>
            </form>
<pre>
        uint weight; // weight 는 대표단에 의해 누적됩니다.
        bool voted;  // 만약 이 값이 true라면, 그 사람은 이미 투표한 것 입니다.
        address delegate; // 투표에 위임된 사람
        uint vote;   // 투표된 제안의 인덱스 데이터 값
    }
  
    // 이것은 단일 제안에 대한 유형입니다.
    struct Proposal {

        bytes32 name;   // 간단한 명칭 (최대 32바이트)

        uint voteCount; // 누적 투표 수
    }

    address public chairperson;

    // 이것은 각각의 가능한 주소에 대해
    // `Voter` 구조체를 저장하는 상태변수를 선언합니다.
    mapping(address => Voter) public voters;

    // 동적으로 크기가 지정된 `Proposal` 구조체의 배열입니다.
    Proposal[] public proposals;

    /// `proposalNames` 중 하나를 선택하기 위한 새로운 투표권을 생성십시오.
</pre>
            <form action="" id="my_form_19">
                <textarea id="code19" name="code" placeholder="코드를 입력해주세요."></textarea>
                <input type="submit" value="제출하기" id="_submit19"><br>
            </form>
<pre>
    (bytes32[] proposalNames) public {
        chairperson = msg.sender;

        voters[chairperson].weight = 1;

        // 각각의 제공된 제안서 이름에 대해,
        // 새로운 제안서 개체를 만들어 배열 끝에 추가합니다.
        for (uint i = 0; i &lt; proposalNames.length; i++) {

        // `Proposal({...})` creates a temporary
        // Proposal object and `proposals.push(...)`
        // appends it to the end of `proposals`.

            proposals.push(Proposal({
      
            name: proposalNames[i],

            voteCount: 0
            }));
        }
    }

    // `voter` 에게 이 투표권에 대한 권한을 부여하십시오.
    // 오직 `chairperson` 으로부터 호출받을 수 있습니다.

    function giveRightToVote(address voter) public {

    // `require`의 인수가 `false`로 평가되면,
    // 그것은 종료되고 모든 변경내용을 state와
    // Ether Balance로 되돌립니다.
    // 함수가 잘못 호출되면 이것을 사용하는 것이 좋습니다.
    // 그러나 조심하십시오,
    // 이것은 현재 제공된 모든 가스를 소비할 것입니다.
    // (이것은 앞으로 바뀌게 될 예정입니다)

        require(
            (msg.sender == chairperson) &&
            !voters[voter].voted &&
            (voters[voter].weight == 0)
        );
        voters[voter].weight = 1;
    }
   
    /// `to` 로 유권자에게 투표를 위임하십시오.

    function delegate(address to) public {
    // 참조를 지정하십시오.
        Voter storage sender = voters[msg.sender];
        require(!sender.voted);

        // 자체 위임은 허용되지 않습니다.
        require(to != msg.sender);

        // `to`가 위임하는 동안 delegation을 전달하십시오.
        // 일반적으로 이런 루프는 매우 위험하기 때문에,
        // 너무 오래 실행되면 블록에서 사용가능한 가스보다
        // 더 많은 가스가 필요하게 될지도 모릅니다.
        // 이 경우 위임(delegation)은 실행되지 않지만,
        // 다른 상황에서는 이러한 루프로 인해
        // 스마트 컨트랙트가 완전히 "고착"될 수 있습니다.

        while (voters[to].delegate != address(0)) {
            to = voters[to].delegate;
   
            // 우리는 delegation에 루프가 있음을 확인 했고 허용하지 않았습니다.
            require(to != msg.sender);
        }

        // `sender` 는 참조이므로,
        // `voters[msg.sender].voted` 를 수정합니다.
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegate_ = voters[to];
</pre>
            <form action="" id="my_form_20">
                <textarea id="code20" name="code" placeholder="코드를 입력해주세요."></textarea>
                <input type="submit" value="제출하기" id="_submit20"><br>
            </form>
<pre>
        // 대표가 이미 투표한 경우,
        // 투표 수에 직접 추가 하십시오
            proposals[delegate_.vote].voteCount += sender.weight;
        } else {
            // 대표가 아직 투표하지 않았다면,
            // weight에 추가하십시오.
            delegate_.weight += sender.weight;
        }
    }

    /// (당신에게 위임된 투표권을 포함하여)
    /// `proposals[proposal].name` 제안서에 투표 하십시오.
    function vote(uint proposal) public {
        Voter storage sender = voters[msg.sender];
        require(!sender.voted);
</pre>
            <form action="" id="my_form_21">
                <textarea id="code21" name="code" placeholder="코드를 입력해주세요."></textarea>
                <input type="submit" value="제출하기" id="_submit21"><br>
            </form>
<pre>
        sender.vote = proposal;

        // 만약 `proposal` 이 배열의 범위를 벗어나면
        // 자동으로 throw 하고 모든 변경사항을 되돌릴 것입니다.
        proposals[proposal].voteCount += sender.weight;
    }

    /// @dev 모든 이전 득표를 고려하여 승리한 제안서를 계산합니다.
    function winningProposal() public view
    returns (uint winningProposal_)
    {
        uint winningVoteCount = 0;
        for (uint p = 0; p &lt; proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal_ = p;
            }
        }
    }

    // winningProposal() 함수를 호출하여
    // 제안 배열에 포함된 승자의 index를 가져온 다음
    // 승자의 이름을 반환합니다.
    function winnerName() public view
    returns (bytes32 winnerName_)
    {
        winnerName_ = proposals[winningProposal()].name;
    }
}
    </pre>
                </div>
            </div>
        </div>
    </div>
    <script src="./answer.js"></script>
    </body>
</html>
