<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="includeHTML.js" type="text/js"">
    <title>두 번째</title>
    <style>
      @import url("style.css");
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap");
      @import url("includeHTML.js");
    </style>
  </head>
  <header>/
    <header>
        <span class="previous"><a href="1.html">💕</a></span>
        <span class="title">Java To Solidity</span>
        <span class="next"><a href="3.html">💕</a></span>
    </header>
  </header>
  <body>
    <div class="container">
      <div class="item">
        <h1>개념설명</h1>
        <div class="box">
          <div class="text"><details>
            <summary>pragma solidity + ^버전정보</summary>
            <p>Pragma를 통해 솔리디티 컴파일러 버전을 제한합니다.</p>
        </details>
        <details>
            <summary>Contract</summary>
            <p>Contract를 통해 이 코드가 스마트 컨트랙트임을 나타냅니다. 솔리디티의 컨트랙트는 자바의 클래스로 나타냈습니다.<br>컨트랙트는 상속과 다형성을 지원하므로 다른 컨트랙트로부터 상속되거나 한 솔리디티 파일에 여러 개의 컨트랙트가 정의될 수 있습니다.</p>
        </details>
        <details>
            <summary>Struct</summary>
            <p>필요한 자료형들을 가지고 새롭게 정의하는 사용자 정의 타입으로 솔리디티의 구조체입니다.<br>함수 외부에서 구조체를 명시하면 storage에 저장되고 함수 내부에서 구조체를 명시하면 memory에 저장됩니다.<br>(간단하게 말하면 storage는 영구 저장, memory는 임시 저장입니다. 자세한 건 밑에 따로 설명했습니다.)</p>
        </details>
        <details>
            <summary>값 타입</summary>
            <p>bool : 논리자료형 true/false.<br>
                int : 정수형<br>
                uint : 부호가 없는 정수형 unsigned int. 솔리디티는 주로 uint 사용<br>
                address : 크기가 20bytes인 이더리움 주소 값 (0xbFv15646A0…)<br>
                bytes : 바이트. 문자열저장<br>
                enum : 열거형<br>
                Java와 Solidity는  값 타입을 적는 순서에 약간의 차이가 있다.<br> 
                Java> public int a;<br>
                Solidity> uint public a;
            </p>
        </details>
        <details>
            <summary>매핑(mapping)</summary>
            <p>- 구조화된 데이터를 저장하는 방법.<br>
                - Key&Value를 쌍으로 저장<br>
                - mapping (Key(=address)=>Value(=uint))와 같은 형태로 사용<br>
                Java> public HashMap&lt;address, Voter&gt;voters = new HashMap&lt;address, Voter&gt;;<br>
                Solidity> mapping(address => Voter) public voters;
            </p>
        </details>
        <details>
            <summary>배열</summary>
            <p>같은 타입의 변수들을 묶은 자료구조</p>
        </details>
        <details>
            <summary>생성자(Constructor)</summary>
            <p>-객체의 초기화가 필요하다면 생성자 안에 작성<br>
                -생성자를 사용하려면 단 1개만 작성해야 한다. 2개 이상 사용시 오류 발생<br>
                -생성자를 직접 작성하지 않으면 기본생성자(default constructor) 자동 생성<br>
                -생성자의 가시성은 internal 또는 public<br>
                >생성자는 특별한 함수이기 때문에 자바 코드에선 함수로 나타내었다. Solidity 코드로 작성할 때는 함수가 아닌 constructor로 바꾸어 작성하세요.<br>
            </p>
        </details>
        <details>
            <summary>데이터 위치</summary>
            <p>memory<br>
                임시적으로 저장되는 변수를 말합니다. 이는 contract 함수에 대한 외부 호출들이 일어나는 사이에 지워집니다. 매개변수와 리턴값은 memory로 선언합니다.<br><br>
                storage<br>
                블록체인에 영구적으로 저장되는 변수를 말합니다. 저장되는 변수의 종류는 상태 변수, 함수 내 로컬 변수가 있습니다.
            </p>
        </details>
        <details>
            <summary>msg.sender</summary>
            <p>현재 함수를 호출한 사람 (혹은 스마트 컨트랙트)의 주소이며 모든 함수에서 이용 가능한 전역 변수입니다.</p>
        </details>
        <details>
            <summary>메세지 프로퍼티(Message Properties)</summary>
            <p>계약은 msg 프로퍼티를 사용해 계약을 호출한 사람이 보낸 메세지를 확인합니다. msg 프로퍼티는 다음과 같은 정보를 담습니다.<br>
                <table>
                    <tr>
                        <th>정보</th>
                        <th>타입</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td>data</td>
                        <td>byte</td>
                        <td>호출 데이터</td>
                    </tr>
                    <tr>
                        <td>sender</td>
                        <td>address</td>
                        <td>계약을 호출한 이더리움 주소</td>
                    </tr>
                    <tr>
                        <td>value</td>
                        <td>uint</td>
                        <td>계약 주소로 보낸 Ether량</td>
                    </tr>
                    <tr>
                        <td>gas</td>
                        <td>uint</td>
                        <td>gas limit에서 함수를 호출하고 남은 가스</td>
                    </tr>
                </table>
                </p>
        </details>
        <details>
            <summary>Push</summary>
            <p>Solidity는 push를 이용하여 배열에 값을 입력 한다.<br>
                Java code><br> 
                proposals.name=proposalNames[i];<br>
                &nbsp;&nbsp;&nbsp;&nbsp;proposals.voteCount=0;<br>
                Solidity code><br>
                proposals.push(Proposal({<br>
                &nbsp;&nbsp;&nbsp;&nbsp;name: proposalNames[i],<br>
                &nbsp;&nbsp;&nbsp;&nbsp;voteCount: 0<br>
                })
                </p>
        </details>
        <details>
            <summary>접근제어자(가시성)</summary>
            <p>-external : 외부컨트랙트만 접근가능(같은 함수 내부에서 호출되면 안됨), 상태변수는 external 불가능<br><br>
                -internal : 컨트랙트 내부호출가능, 상속받은 컨트랙트도 호출가능, 상태변수는 디폴트로 internal 선언<br><br>
                -public : 컨트랙트 내부호출 가능, 상속받은 컨트랙트도 호출가능, 외부컨트랙트도 호출가능<br><br>
                -private: 컨트랙트 내부만 호출가능
                </p>
        </details>
        <details>
            <summary>함수(function)</summary>
            <p>기본적으로 함수는 public.<br>
                함수는 다음과 같이 사용한다. 자바 함수와는 순서가 약간 다르다.<br>
                솔리디티 코드 ex><br>
                fuction nameA(address a) public view returns(uint b) {<br>
                // 함수 내용<br>
                }
                </p>
        </details>
        <details>
            <summary>returns</summary>
            <p>솔리디티는 반환값의 타입을 지정해줘야하며 다중 반환값 처리는 순서대로 처리 된다.</p>
        </details>
        <details>
            <summary>함수제어자(function modifier)</summary>
            <p>-View : 데이터를 읽을 수만 있습니다. 상태 변화가 없는 함수에는 view를 붙입니다. 즉, 함수는 데이터를 보기만하고 변경하지 않는다는 뜻입니다.<br><br>
                -pure : 어떤 데이터도 접근하지 않는 것을 의미합니다. 함수에 전달된 인자값에 따라서 반환값이 정해집니다.
                </p>
        </details>
        <details>
            <summary>require</summary>
            <p>함수 실행 전에 참이어야 하는 특정 조건을 확인하는 데 사용합니다. 특정 조건이 참이 아닐 때 함수가 에러 메세지를 발생하고 실행을 멈추게 됩니다.<br>
                자바 코드><br>
                if (msg.sender != chairperson) { <br>
                &nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Only chairperson can give right to vote.");<br>
                &nbsp;&nbsp;&nbsp;&nbsp;System.exit(0); // 실행 멈추는 코드<br>
                }<br>
                솔리디티 코드><br>
                require(<br>
                &nbsp;&nbsp;&nbsp;&nbsp;msg.sender == chairperson,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;"Only chairperson can give right to vote."<br>
                );
                </p>
        </details>
        <details>
            <summary>event</summary>
            <p>event는 Dapp의 데이터 출력 수단(Log)입니다. 이벤트를 선언 후 이 이벤트를 호출하면 매개변수값과 함께 호출한 기록이 Transaction Receipt 라 불리는 트랜잭션 결과에 저장됩니다.<br>
                (DApp이란 스마트 컨트랙트를 구현한 블록체인의 탈중앙화 분산 애플리케이션)
                </p>
        </details>
        <details>
            <summary>_</summary>
            <p>함수 인자명 앞 또는 private 제한자가 붙은 함수명 앞에 _를 붙여야합니다.</p>
        </details>
        <details>
            <summary>transfer</summary>
            <p>계약이 다른 이에게 Ether를 전송하는 함수입니다.</p>
        </details>
        <details>
            <summary>send</summary>
            <p>send는 address의 멤버변수로 해당 주소에게로 송금하는 함수입니다.</p>
        </details>
        <details>
            <summary>함수제어자(modifier)</summary>
            <p>함수가 실행되기 전에 요구조건을 만족시키는지 확인하는 작업을 해줍니다.<br>
                다른 함수들에 대한 접근을 제어하기 위해 사용되는 유사 함수입니다. 보통 함수 실행 전에 요구사항 충족 여부를 확인하는데 사용합니다.<br>
                함수 인자명 앞 또는 private 제한자가 붙은 함수명 앞에 _를 붙여야합니다.<br>
                선언과 사용은 함수 제어자 마지막에 _;를 붙여 나머지 내용을 실행할 수 있도록 해주어야합니다.<br>
                </p>
        </details>
        <details>
            <summary>payable</summary>
            <p>payable 키워드는 계약 계정에 외부에서 이더를 송금 받을 수 있도록 합니다. 즉, 계약이 A에게 송금을 받으려면 A가 호출하는 함수에 payable 키워드가 있어야합니다.<br>
                payable 함수는 다음과 같이 사용합니다.<br>
                function 함수이름() payable public { <br>
                //함수 내용<br>
                }
                </p>
        </details>
        <details>
            <summary>enum</summary>
            <p>Enum은 열거형으로 사용자 정의 타입을 만드는 한 가지 방법입니다. <br>
                - 열거형(index를 부여한 자료형)<br>
                - 값을 정수타입으로 리턴
                </p>
        </details>
        <details>
            <summary>emit</summary>
            <p>emit이란 키워드를 이용하여 이벤트를 발생시킨다</p>
        </details>
        <details>
            <summary>selfdestruct</summary>
            <p>받는 사람 주소를 뜻하며 현재 컨트랙트를 삭제하고 계정의 나머지 이더를 받는 사람 주소로 보냅니다.</p>
        </details>
        <details>
            <summary>어셈블리(assembly)</summary>
            <p>low level에서 EVM에 접근하는 방법입니다.</p>
        </details>
        </div>
          
        </div>
      </div>
      <div class="item">
        <h1>공개경매</h1>
        <div class="box">
          <div class="text" include-html="04.html">
            <pre>
public class SimpleAuction {

    public static void main(String[] args) {
        address payable public beneficiary;
        public uint auctionEndTime;
 
        public address highestBidder;
        public uint highestBid;
 
        HashMap&lt;address,uint> pendingReturns = new HashMap&lt;address,uint>();
 
        bool ended;
 
        event HighestBidIncreased(address bidder, uint amount);
        event AuctionEnded(address winner, uint amount);
 
        public SimpleAuction(
            uint _biddingTime,
            address payable _beneficiary
        ) {
            beneficiary = _beneficiary;
            auctionEndTime = block.timestamp + _biddingTime;
        }
 
        public bid() payable {
            if (block.timestamp > auctionEndTime) {
               System.out.println("Auction already ended.");
                System.exit(0); 
            }
 
            if (msg.value &lt;= highestBid) {
                System.out.println("There already is a higher bid.");
                System.exit(0); 
            }
 
            if (highestBid != 0) {
                pendingReturns[highestBidder] += highestBid;
            }
            highestBidder = msg.sender;
            highestBid = msg.value;
            emit HighestBidIncreased(msg.sender, msg.value);
        }
 
        public bool withdraw() {
            uint amount = pendingReturns[msg.sender];
            if (amount > 0) {
                pendingReturns[msg.sender] = 0;
 
                if (!msg.sender.send(amount)) {
                    pendingReturns[msg.sender] = amount;
                    return false;
                }
            }
            return true;
        }
 
        public void auctionEnd() {
            if (block.timestamp &lt; auctionEndTime) { 
              System.out.println("Auction not yet ended.");
               System.exit(0); 
            }
            if (ended) { 
                System.out.println("auctionEnd has already been called.");
                System.exit(0); 
            }
 
            ended = true;
            emit AuctionEnded(highestBidder, highestBid);
            
            beneficiary.transfer(highestBid);
        }
    }
 
}
            </pre>
            </div>
        </div>
      </div>
      <div class="item">
        <h1>입력창</h1>
        <div class="box">
          <div class="text">
            <pre>
pragma solidity ^0.4.21;
               </pre>
                        <form action="" id="my_form_13">
                            <textarea id="code13" name="code" placeholder="코드를 입력해주세요."></textarea>
                            <input type="submit" value="제출하기" id="_submit13"><br>
                        </form>
                <pre>
    // 경매의 파라미터. 시간은 아래 둘 중 하나입니다.
    // 앱솔루트 유닉스 타임스탬프 (seconds since 1970-01-01)
    // 혹은 시한(time period) in seconds.
    address public beneficiary;
    uint public auctionEnd;
        
    // 경매의 현재 상황.
    address public highestBidder;
    uint public highestBid;
        
    // 이전 가격 제시들의 수락된 출금..
    mapping(address => uint) pendingReturns;
        
    // 마지막에 true 로 설정, 어떠한 변경도 허락되지 않습니다.
    bool ended;
        
    // 변경에 발생하는 이벤트
    event HighestBidIncreased(address bidder, uint amount);
    event AuctionEnded(address winner, uint amount);
        
    // 아래의 것은 소위 "natspec"이라고 불리우는 코멘트,
    // 3개의 슬래시에 의해 알아볼 수 있습니다.
    // 이것을 유저가 트렌젝션에 대한 확인을 요청 받을때
    // 보여집니다.
        
    /// 수혜자의 주소를 대신하여 두번째 가격제시 기간 '_biddingTime'과
    /// 수혜자의 주소 '_beneficiary' 를 포함하는
    /// 간단한 옥션을 제작합니다.
                </pre>
                        <form action="" id="my_form_14">
                            <textarea id="code14" name="code" placeholder="코드를 입력해주세요."></textarea>
                            <input type="submit" value="제출하기" id="_submit14"><br>
                        </form>
                <pre>
    uint _biddingTime,
    address _beneficiary
        ) public {
        beneficiary = _beneficiary;
        auctionEnd = now + _biddingTime;
    }
                        
    /// 경매에 대한 가격제시와 값은
    /// 이 transaction과 함께 보내집니다.
    /// 값은 경매에서 이기지 못했을 경우만
    /// 반환 받을 수 있습니다.
    function bid() public payable {
        // 어떤 인자도 필요하지 않음, 모든
        // 모든 정보는 이미 트렌젝션의
        // 일부이다. 'payable' 키워드는
        // 이더를 지급는 것이 가능 하도록
        // 하기 위하여 함수에게 요구됩니다.
                        
        // 경매 기간이 끝났으면
        // 되돌아 갑니다.
        require(now &lt;= auctionEnd);
                        
        // 만약 이 가격제시가 더 높지 않다면, 돈을
        // 되돌려 보냅니다.
        require(msg.value > highestBid);
                        
        if (highestBid != 0) {
            // 간단히 highestBidder.send(highestBid)를 사용하여
            // 돈을 돌려 보내는 것은 보안상의 리스크가 있습니다.
            // 그것은 신뢰되지 않은 콘트렉트를 실행 시킬수 있기 때문입니다.
            // 받는 사람이 그들의 돈을 그들 스스로 출금 하도록 하는 것이
            // 항상 더 안전합니다.
            pendingReturns[highestBidder] += highestBid;
        }
        highestBidder = msg.sender;
        highestBid = msg.value;
        emit HighestBidIncreased(msg.sender, msg.value);
    }
                        
    /// 비싸게 값이 불러진 가격제시 출금.
                    </pre>
                        <form action="" id="my_form_15">
                            <textarea id="code15" name="code" placeholder="코드를 입력해주세요."></textarea>
                            <input type="submit" value="제출하기" id="_submit15"><br>
                        </form>
                    <pre>
    public returns (bool) {
        uint amount = pendingReturns[msg.sender];
        if (amount > 0) {
            // 받는 사람이 이 `send` 반환 이전에 받는 호출의 일부로써
            // 이 함수를 다시 호출할 수 있기 때문에
            // 이것을 0으로 설정하는 것은 중요하다.
            pendingReturns[msg.sender] = 0;
                        
            if (!msg.sender.send(amount)) {
                // 여기서 throw를 호출할 필요가 없습니다, 빚진 양만 초기화.
                pendingReturns[msg.sender] = amount;
                return false;
            }
        }
        return true;
    }
                        
    /// 이 경매를 끝내고 최고 가격 제시를
    /// 수혜자에게 송금.
                        </pre>
                        <form action="" id="my_form_16">
                            <textarea id="code16" name="code" placeholder="코드를 입력해주세요."></textarea>
                            <input type="submit" value="제출하기" id="_submit16"><br>
                        </form>
                        <pre>
        // 이것은 다른 콘트렉트와 상호작용하는 함수의 구조를 잡는 좋은 가이드 라인입니다.
        // (i.e. 그것들은 이더를 보내거나 함수를 호출합니다.)
        // 3가지 단계:
        // 1. 조건을 확인
        // 2. 동작을 수행  (잠재적으로 변경되는 조건)
        // 3. interacting with other contracts
        // If these phases are mixed up, the other contract could call
        // back into the current contract and modify the state or cause
        // effects (ether payout) to be performed multiple times.
        // If functions called internally include interaction with external
        // contracts, they also have to be considered interaction with
        // external contracts.
        
        // 1. 조건
        require(now >= auctionEnd); // auction did not yet end
        require(!ended); // this function has already been called
        
        // 2. 영향
        ended = true;
        emit AuctionEnded(highestBidder, highestBid);
        
        // 3. 상호작용
        beneficiary.transfer(highestBid);
    }
}
                        
               </pre>   
          </div>
        </div>
      </div>
    </div>
    <script src="./answer.js"></script>
  </body>
</html>
